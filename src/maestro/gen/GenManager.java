/**
 * Copyright 2017 Felipe Hernández
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the 
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

package maestro.gen;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Hashtable;

import probDist.ContProbDist;
import maestro.ContVar;
import maestro.DiscVar;
import maestro.gen.GenWrapper;
import maestro.gen.Generator;
import maestro.gen.aco.ACO;
import maestro.gen.aco.MetroACO;
import maestro.gen.cmaes.CMAES;
import maestro.gen.ga.GA;
import maestro.gen.gd.GD;
import maestro.gen.hc.HC;
import maestro.pop.Partition;
import maestro.pop.Population;
import maestro.solution.Solution;
import maestro.solution.SolutionRoot;
import maestro.solution.SolutionWrapper;
import utilities.geom.Point2I;

/**
 * This class manages the solution generator algorithms used in MAESTRO
 * @author Felipe Hernández
 */
public class GenManager
{
	
	// --------------------------------------------------------------------------------------------
	// Constants
	// --------------------------------------------------------------------------------------------
	
	/**
	 * The minimum number of solutions in the population in order to allow the generation of new 
	 * solutions
	 */
	public final static int MIN_POP_SIZE = 2;
	
	/**
	 * Default value for the <code>genRatio</code> attribute
	 */
	public final static double D_GEN_RATIO = 0.15;
	
	/**
	 * Default value for the <code>genMin</code> attribute
	 */
	public final static double D_GEN_MIN = 0.1;
	
	/**
	 * Default value for {@link #absGenMin}
	 */
	public final static int D_ABS_GEN_MIN = 0;
	
	/**
	 * Default value for the <code>weightPop</code> attribute
	 */
	public final static double D_WEIGHT_POP = 0.0;
	
	/**
	 * Default value for the <code>weightPart1</code> attribute
	 */
	public final static double D_WEIGHT_PART_1 = 0.75;
	
	/**
	 * Default value for the <code>weightElite</code> attribute
	 */
	public final static double D_WEIGHT_ELITE = 1.0;
	
	// --------------------------------------------------------------------------------------------
	// Attributes
	// --------------------------------------------------------------------------------------------
	
	/**
	 * The list with the algorithms that generate values for new solutions 
	 */
	private ArrayList<GenWrapper> generators;
	
	/**
	 * The list with the generators in their original order
	 */
	private ArrayList<GenWrapper> genOrigOrder;
	
	/**
	 * The list of partitions that make up the current population of solutions. Each partition has
	 * a different rarity standard and are sorted in ascending rarity standard order.
	 */
	private Population population;
	
	/**
	 * The number of solutions in the current population
	 */
	private int popSize;
	
	/**
	 * The number of solutions for each generator to generate as a ratio of <code>popSize</code>
	 * when each is showing the same performance. The number of solutions to generate is given by:
	 * <i>toGenerate = performanceIndex*<code>genRatio</code>*<code>popSize</code></i>. The
	 * performance index is computed as: <i>performanceIndex = numberOfGenerators*generatorWeight
	 * /totalWeight</i>.
	 */
	private double genRatio;
	
	/**
	 * The minimum number of solutions that should be generated by each generator as a percentage
	 * of <code>popSize</code>
	 */
	private double genMin;
	
	/**
	 * The absolute minimum number of solutions that should be generated by each generator
	 */
	private int absGenMin;
	
	/**
	 * The weight given to the percentage of solutions in the entire population that were created 
	 * by a generator to determine its overall relative weight. The overall weight for a generator 
	 * is: <br><i>overallWeight = <code>weightPop</code>*%_population + <code>weightPart1</code>
	 * *%_first_partition + <code>weightElite</code>*%_elite_history</i>.
	 */
	private double weightPop;
	
	/**
	 * The weight given to the percentage of solutions in the first partition of the population 
	 * that were created by a generator to determine its overall relative weight. The overall 
	 * weight for a generator is: <br><i>overallWeight = <code>weightPop</code>*%_population + 
	 * <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*%_elite_history</i>.
	 */
	private double weightPart1;
	
	/**
	 * The weight given to the percentage of solutions in the history of elite solutions that were 
	 * created by a generator to determine its overall relative weight. The overall weight for a 
	 * generator is: <br><i>overallWeight = <code>weightPop</code>*%_population + 
	 * <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*%_elite_history</i>.
	 */
	private double weightElite;
	
	/**
	 * The index of the last generator used
	 */
	private int lastGen;
	
	/**
	 * True if within an inner cycle run not all the generator methods have generated new solutions
	 */
	private boolean firstLap;
	
	/**
	 * The log with the history of the number of generated solutions. Each entry on the log is a 
	 * (Inner cycle identifier, generator short identifier, number of solutions, total time, and
	 * time per solution) tuple in a string separated by tabs.
	 */
	private ArrayList<String> genHist;
	
	// --------------------------------------------------------------------------------------------
	// Constructor
	// --------------------------------------------------------------------------------------------
	
	/**
	 * Initializes the generator manager
	 */
	public GenManager()
	{
		generators		= new ArrayList<GenWrapper>();
		genOrigOrder	= new ArrayList<GenWrapper>();
		population		= null;
		popSize			= -1;
		genRatio		= D_GEN_RATIO;
		genMin			= D_GEN_MIN;
		setAbsGenMin(D_ABS_GEN_MIN);
		weightPop		= D_WEIGHT_POP;
		weightPart1		= D_WEIGHT_PART_1;
		weightElite		= D_WEIGHT_ELITE;
		lastGen			= -1;
		firstLap		= true;
		genHist			= new ArrayList<String>();
	}
	
	// --------------------------------------------------------------------------------------------
	// Methods
	// --------------------------------------------------------------------------------------------
	
	/**
	 * @return The list with the algorithms that generate values for new solutions 
	 */
	public ArrayList<GenWrapper> getGenerators() 
	{
		return genOrigOrder;
	}
	
	/**
	 * @return The list of partitions that make up the current population of solutions. Each 
	 * partition has a different rarity standard and are sorted in ascending rarity standard order.
	 */
	public Population getPopulation() 
	{
		return population;
	}

	/**
	 * @param population The list of partitions that make up the current population of solutions. 
	 * Each partition has a different rarity standard and are sorted in ascending rarity standard 
	 * order.
	 */
	public void setPopulation(Population population) 
	{
		this.population = population;
	}

	/**
	 * @return The number of solutions in the current population
	 */
	public int getPopSize() 
	{
		return popSize;
	}

	/**
	 * @param popSize The number of solutions in the current population
	 */
	public void setPopSize(int popSize) 
	{
		this.popSize = popSize;
	}
	
	/**
	 * @return The number of solutions for each generator to generate as a ratio of 
	 * <code>popSize</code> when each is showing the same performance. The number of solutions to 
	 * generate is given by: <i>toGenerate = performanceIndex*<code>genRatio</code>*
	 * <code>popSize</code></i>. The performance index is computed as: <i>performanceIndex = 
	 * numberOfGenerators*generatorWeight/totalWeight</i>.
	 */
	public double getGenRatio() 
	{
		return genRatio;
	}

	/**
	 * @param genRatio The number of solutions for each generator to generate as a ratio of 
	 * <code>popSize</code> when each is showing the same performance. The number of solutions to 
	 * generate is given by: <i>toGenerate = performanceIndex*<code>genRatio</code>*
	 * <code>popSize</code></i>. The performance index is computed as: <i>performanceIndex = 
	 * numberOfGenerators*generatorWeight/totalWeight</i>.
	 */
	public void setGenRatio(double genRatio) 
	{
		this.genRatio = genRatio < 0.0 ? 0.0 : genRatio;
	}

	/**
	 * @return The minimum number of solutions that should be generated by each generator as a 
	 * percentage of <code>popSize</code>
	 */
	public double getGenMin() 
	{
		return genMin;
	}

	/**
	 * @param genMin The minimum number of solutions that should be generated by each generator as 
	 * a percentage of <code>popSize</code>
	 */
	public void setGenMin(double genMin)
	{
		this.genMin = genMin < 0.0 ? 0.0 : genMin;
		this.genMin = genMin > 1.0 ? 1.0 : genMin;
	}
	
	/**
	 * @return {@link #absGenMin}
	 */
	public int getAbsGenMin()
	{
		return absGenMin;
	}

	/**
	 * @param {@link #absGenMin}
	 */
	public void setAbsGenMin(int absGenMin) 
	{
		this.absGenMin = absGenMin < 0 ? 0 : absGenMin;
	}

	/**
	 * @return The weight given to the percentage of solutions in the entire population that were 
	 * created by a generator to determine its overall relative weight. The overall weight for a 
	 * generator is: <br><i>overallWeight = <code>weightPop</code>*%_population + 
	 * <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*%_elite_history</i>.
	 */
	public double getWeightPop()
	{
		return weightPop;
	}

	/**
	 * @param weightPop The weight given to the percentage of solutions in the entire population 
	 * that were created by a generator to determine its overall relative weight. The overall 
	 * weight for a generator is: <br><i>overallWeight = <code>weightPop</code>*%_population + 
	 * <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*%_elite_history</i>.
	 */
	public void setWeightPop(double weightPop)
	{
		this.weightPop = weightPop;
	}

	/**
	 * @return The weight given to the percentage of solutions in the first partition of the 
	 * population that were created by a generator to determine its overall relative weight. The 
	 * overall weight for a generator is: <br><i>overallWeight = <code>weightPop</code>*
	 * %_population + <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*
	 * %_elite_history</i>.
	 */
	public double getWeightPart1() 
	{
		return weightPart1;
	}

	/**
	 * @param weightPart1 The weight given to the percentage of solutions in the first partition of 
	 * the population that were created by a generator to determine its overall relative weight. 
	 * The overall weight for a generator is: <br><i>overallWeight = <code>weightPop</code>*
	 * %_population + <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*
	 * %_elite_history</i>.
	 */
	public void setWeightPart1(double weightPart1) 
	{
		this.weightPart1 = weightPart1;
	}

	/**
	 * @return The weight given to the percentage of solutions in the history of elite solutions 
	 * that were created by a generator to determine its overall relative weight. The overall 
	 * weight for a generator is: <br><i>overallWeight = <code>weightPop</code>*%_population + 
	 * <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*%_elite_history</i>.
	 */
	public double getWeightElite()
	{
		return weightElite;
	}

	/**
	 * @param weightElite The weight given to the percentage of solutions in the history of elite 
	 * solutions that were created by a generator to determine its overall relative weight. The 
	 * overall weight for a generator is: <br><i>overallWeight = <code>weightPop</code>*
	 * %_population + <code>weightPart1</code> *%_first_partition + <code>weightElite</code>*
	 * %_elite_history</i>.
	 */
	public void setWeightElite(double weightElite) 
	{
		this.weightElite = weightElite;
	}

	/**
	 * @return The log with the history of the number of generated solutions. Each entry on the log 
	 * is a (Inner cycle identifier, generator short identifier, number of solutions) tuple in a 
	 * string separated by tabs.
	 */
	public ArrayList<String> getGenHist()
	{
		return genHist;
	}
	
	/**
	 * Adds a new generator method
	 * @param generator The generator method to be added
	 */
	public void addGenerator(Generator generator)
	{
		GenWrapper wrapper = new GenWrapper(generator);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds the default selection of generators
	 */
	public void defaultGenerators()
	{
		// Add CMA-ES generator
		Generator cmaes = new CMAES();
		GenWrapper wrapper = new GenWrapper(cmaes);
		addGenWrapper(wrapper);
		
		// Add GA generator
		Generator ga = new GA();
		wrapper = new GenWrapper(ga);
		addGenWrapper(wrapper);
		
		// Add ACO generator
		Generator aco = new ACO();
		wrapper = new GenWrapper(aco);
		addGenWrapper(wrapper);
		
		// Add HC generator
		Generator hc = new HC();
		wrapper = new GenWrapper(hc);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds an alternative selection of generators
	 */
	public void alternativeGenerators()
	{
		// Add CMA-ES generator
		Generator cmaes = new CMAES(0.1, 0.6);
		GenWrapper wrapper = new GenWrapper(cmaes);
		addGenWrapper(wrapper);
		
		// Add GA generator 1
		Generator ga = new GA(0, 0.5, 0.2, 0.75, 1, 0.2, 0.2, 0, 0.2, 0.075, 1.0, 1.0, 1.0, 0.1);
		wrapper = new GenWrapper(ga);
		addGenWrapper(wrapper);
		
		// Add GA generator 2
		ga = new GA(2, 0.5, 0.2, 0.75, 1, 0.0, 0.2, 0, 0.2, 0.075, 1.0, 1.0, 1.0, 0.1);
		wrapper = new GenWrapper(ga);
		addGenWrapper(wrapper);
		
		// Add ACO generator
		Generator aco = new ACO(0.3, 0.0, 0.15, 0.4, 0.4);
		wrapper = new GenWrapper(aco);
		addGenWrapper(wrapper);
		
		// Add HC generator 1
		Generator hc = new HC(0.6, 0.2, 0.6, 0.6, 0, 0, 1, 3.0);
		wrapper = new GenWrapper(hc);
		addGenWrapper(wrapper);
		
		// Add HC generator 2
		hc = new HC(0.4, 0.2, 0.3, 0.6, 0, 0, 1, 1.5);
		wrapper = new GenWrapper(hc);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Ant Colony Optimization (ACO) generator method with default parameters
	 */
	public void addACOGenerator()
	{
		Generator aco = new ACO();
		GenWrapper wrapper = new GenWrapper(aco);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Ant Colony Optimization (ACO) generator method
	 * @param minPheromone The minimum amount of pheromone a value can have expressed as a 
	 * percentage of the average pheromone value
	 * @param elitism The rate at which the best solution found so far deposits pheromone. The 
	 * complement is deposited by the best ants in the iteration. Preferably between 0 and 1.
	 * @param randomP The probability of generating uniformly-distributed random values for 
	 * continuous variables in new solutions
	 * @param q This variable defines how the solutions in the buffer are assigned weights. The 
	 * weights are used to compute the pheromone update. Q has to be positive. A value of 0 means 
	 * only the most fitted solution may lay pheromone. A large value of q means that every 
	 * solution contributes to the pheromone with little regard for their fitness value.
	 * @param xi This parameter is used to compute the standard deviation of normal probability 
	 * functions in order to generate new values for the variables. When generating a new value for 
	 * a given variable, a Gaussian kernel is created from the values of the solutions in the 
	 * archive. A normal distribution is created for each solution with its value being the mean 
	 * and an standard deviation. This deviation is computed by multiplying the xi parameter with 
	 * the average distance between the mean and the values of the other solutions (the other 
	 * means). xi must be positive. A small value tends to speed convergence, while a large value 
	 * tends to perform a more complete search of the solution space.
	 */
	public void addACOGenerator(double minPheromone, double elitism, double randomP, double q, 
								double xi)
	{
		Generator aco = new ACO(minPheromone, elitism, randomP, q, xi);
		GenWrapper wrapper = new GenWrapper(aco);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Metropolis - Ant Colony Optimization (MetroACO) generator method with default 
	 * parameters
	 */
	public void addMetroACOGenerator()
	{
		Generator metroACO	= new MetroACO();
		GenWrapper wrapper	= new GenWrapper(metroACO);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Metropolis - Ant Colony Optimization (MetroACO) generator method
	 * @param greed				{@link maestro.v2.gen.aco.MetroACO#greed}
	 * @param independentRatio	{@link maestro.v2.gen.aco.MetroACO#independentRatio}
	 * @param uniformProb		{@link maestro.v2.gen.aco.MetroACO#uniformProb}
	 * @param groupNumber		{@link maestro.v2.gen.aco.MetroACO#groupNumber}
	 * @param groupPercent		{@link maestro.v2.gen.aco.MetroACO#groupPercent}
	 * @param bandwidthMethod	{@link maestro.v2.gen.aco.MetroACO#bandwidthMethod}
	 * @param bandwidthMult		{@link maestro.v2.gen.aco.MetroACO#bandwidthMult}
	 */
	public void addMetroACOGenerator(double greed, ContProbDist independentRatio, 
										double uniformProb, int groupNumber, double groupPercent, 
										int bandwidthMethod, double bandwidthMult)
	{
		Generator metroACO	= new MetroACO(greed, independentRatio, uniformProb, groupNumber, 
											groupPercent, bandwidthMethod, bandwidthMult);
		GenWrapper wrapper	= new GenWrapper(metroACO);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Genetic Algorithm (GA) generator method with default parameters
	 */
	public void addGAGenerator()
	{
		Generator ga = new GA();
		GenWrapper wrapper = new GenWrapper(ga);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Genetic Algorithm (GA) generator method
	 * Creates a new instance of the Genetic algorithm generator
	 * @param selectionMethod The index of the selection method as defined by the class constants: 
	 * <ul>
	 * <li> <code>SELECTION_ROULETTE</code>: Fitness proportionate selection or Roulette-wheel 
	 * selection
	 * <li> <code>SELECTION_SUS</code>: Stochastic universal sampling selection
	 * <li> <code>SELECTION_TOURNAMENT</code>: Tournament selection </ul>
	 * @param q This variable defines how the solutions in the population are assigned weights. The 
	 * weights are used to compute the likelihood of being selected. <i>q</i> has to be positive. 
	 * A value of <i>0</i> means only the most fitted solution may be selected. A large value of 
	 * <i>q</i> means that every solution has the same probability of being selected with little 
	 * regard for its ranking. Use <code>Double.NaN</code> if an exact uniform distribution should
	 * be used. <i>q</i> is used in all the selection strategies.
	 * @param kPerc The percentage of solutions to be sampled in the Tournament selection strategy
	 * @param trunc The percentage of solutions that are to be truncated from selection. The 
	 * <i>(1 - <code>trunc</code>)*n</i> best solutions are selected.
	 * @param points The number of splitting points in new solutions for the assignment of data 
	 * from either parent 1, parent 2 or uniform crossover. A value of <i>0</i> means that all the 
	 * values in the new solution are computed using the same method.
	 * @param pointUniform The probability of using uniform crossover on a segment of a new 
	 * solution defined by crossover points. <i>0</i> if only point crossover should be used. 
	 * <i>1</i> if only uniform crossover should be used.
	 * @param pUniform The probability of selecting values from parent 1 in uniform crossover. The 
	 * complement is the probability of selecting values from parent 2.
	 * @param unifMethod The index of the uniform crossover method for continuous variables as 
	 * defined by the class constants: <ul>
	 * <li> <code>UNIF_EITHER_OR</code>: Either-or
	 * <li> <code>UNIF_UDIST</code>: Uniform distribution
	 * <li> <code>UNIF_NORMALDIST</code>: Normal distribution </ul>
	 * @param unifDistParam The parameter for probability distribution uniform crossover methods 
	 * for continuous variables: the probability of the generated value to fall outside the range 
	 * between the values of the parents if the uniform distribution method is used; the standard 
	 * deviation of the normal distributions as a percentage of the range between the values of the 
	 * parents if the normal distribution method is used
	 * @param mutationProb The probability of mutating each value in new solutions after crossover
	 * @param randomMutation The weight of the random mutation operator for scalar discrete 
	 * variables. The probability of using the random mutation operator is its weight over the sum 
	 * of the weights of all the operators. 
	 * @param adjacentMutation The weight of the adjacent mutation operator for scalar discrete 
	 * variables. The probability of using the adjacent mutation operator is its weight over the 
	 * sum of the weights of all the operators.
	 * @param boundaryMutation The weight of the boundary mutation operator for scalar discrete 
	 * variables. The probability of using the boundary mutation operator is its weight over the 
	 * sum of the weights of all the operators.
	 * @param gaussianMutation The percentage of a continuous variable range to use as the standard 
	 * deviation of the normal distribution mutation method for continuous variables. 
	 * <code>Double.NaN</code> if the uniform mutation method should be used instead.
	 */
	public void addGAGenerator(int selectionMethod, double q, double kPerc, double trunc, 
			int points, double pointUniform, double pUniform, int unifMethod, double unifDistParam, 
			double mutationProb, double randomMutation,	double adjacentMutation, 
			double boundaryMutation, double gaussianMutation)
	{
		Generator ga = new GA(selectionMethod, q, kPerc, trunc, points, pointUniform, pUniform, 
								unifMethod, unifDistParam, mutationProb, randomMutation, 
								adjacentMutation, boundaryMutation, gaussianMutation);
		GenWrapper wrapper = new GenWrapper(ga);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Hill-Climbing (HC) generator method with default parameters
	 */
	public void addHCGenerator()
	{
		Generator hc = new HC();
		GenWrapper wrapper = new GenWrapper(hc);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Hill-Climbing (HC) generator method
	 * @param qSolutions This parameter defines how the solutions in the population are assigned 
	 * weights. The weights are used to compute the likelihood of being selected. <i>qSolutions</i> 
	 * has to be positive. A value of <i>0</i> means only the most fitted solution may be selected. 
	 * A large value of <i>qSolutions</i> means that every solution has the same probability of 
	 * being selected with little regard for its ranking. Use <code>Double.NaN</code> if an exact 
	 * uniform distribution should be used.
	 * @param qPairs This parameter defines how the solution pairs are assigned weights. The 
	 * weights are used to compute the likelihood of being selected. <i>qPairs</i> has to be 
	 * positive. A value of <i>0</i> means only the most fitted pair may be selected. A large value 
	 * of <i>qPairs</i> means that every pair has the same probability of being selected with 
	 * little regard for its ranking. Use <code>Double.NaN</code> if an exact uniform distribution 
	 * should be used.
	 * @param truncSolutions The percentage of the number of solutions that are to be selected for 
	 * constructing pairs. <i>(1 - <code>truncSolutions</code>)*n</i> solutions are selected.
	 * @param truncPairs The percentage of the number of pairs that are to be selected for 
	 * constructing new solutions. The <i>(1 - <code>truncPairs</code>)*n</i> best pairs are 
	 * selected.
	 * @param selectionMethodSolutions The index of the selection method for the solutions as 
	 * defined by the class constants: <ul>
	 * <li> <code>SELECTION_ROULETTE</code>: Fitness proportionate selection or Roulette-wheel 
	 * selection
	 * <li> <code>SELECTION_SUS</code>: Stochastic universal sampling selection
	 * <li> <code>SELECTION_TOURNAMENT</code>: Tournament selection </ul>
	 * @param slectionMethodPairs The index of the selection method for the pairs as defined by the 
	 * class constants: <ul>
	 * <li> <code>SELECTION_ROULETTE</code>: Fitness proportionate selection or Roulette-wheel 
	 * selection
	 * <li> <code>SELECTION_SUS</code>: Stochastic universal sampling selection
	 * <li> <code>SELECTION_TOURNAMENT</code>: Tournament selection </ul>
	 * @param extent The extent parameter of the search range for new solutions. New solutions are 
	 * generated using a normal distribution to randomly sample each of its new values. The mean of 
	 * the distribution is created by projecting the gradient of the high rank parent (<i>p1</i>) and 
	 * the low rank parent (<i>p2</i>) for each variable <i>i</i> using the extent as a percentage
	 * of the difference: <i>mean = p1i + extent*(p1i - p2i)</i>.
	 * @param amplitude The amplitude parameter of the search range for new solutions. New 
	 * solutions are generated using a normal distribution to randomly sample each of its new 
	 * values. The amplitude is the standard deviation of the distribution as a percentage of 
	 * <i>p1i - p2i</i>.
	 */
	public void addHCGenerator(double qSolutions, double qPairs, double truncSolutions, 
								double truncPairs, int selectionMethodSolutions, 
								int selectionMethodPairs, double extent, double amplitude)
	{
		Generator hc = new HC(qSolutions, qPairs, truncSolutions, truncPairs, 
								selectionMethodSolutions, selectionMethodPairs, extent, amplitude);
		GenWrapper wrapper = new GenWrapper(hc);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Covariance matrix adaptation evolution strategy (CMA-ES) generator method with 
	 * default parameters
	 */
	public void addCMAESGenerator()
	{
		Generator cmaes = new CMAES();
		GenWrapper wrapper = new GenWrapper(cmaes);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Covariance matrix adaptation evolution strategy (CMA-ES) generator method
	 * @param q This variable defines how the solutions in the population are assigned weights. The 
	 * weights are used to compute the multivariate normal distribution to generate the new 
	 * solutions from. <i>q</i> has to be positive and bigger than 0. A value close to <i>0</i> 
	 * means only the most fitted solutions may contribute to the distribution. A large value of 
	 * <i>q</i> means that every solution has the same contribution with little regard for its 
	 * ranking. Use <code>Double.NaN</code> if an exact uniform distribution should be used.
	 * @param trunc The percentage of solutions that are to be truncated from selection. The 
	 * <i>(1 - <code>trunc</code>)*n</i> best solutions are selected.
	 */
	public void addCMAESGenerator(double q, double trunc)
	{
		Generator cmaes = new CMAES(q, trunc);
		GenWrapper wrapper = new GenWrapper(cmaes);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Gradient Descent (GD) generator method with default parameters
	 */
	public void addGDGenerator()
	{
		Generator gd		= new GD();
		GenWrapper wrapper	= new GenWrapper(gd);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new Gradient Descent (GD) generator method
	 * @param greed					{@link maestro.v2.gen.gd.GD#greed}
	 * @param solVicinities			{@link maestro.v2.gen.gd.GD#solVicinities}
	 * @param powerVicinityWeight	{@link maestro.v2.gen.gd.GD#powerVicinityWeight}
	 * @param stepSize				{@link maestro.v2.gen.gd.GD#stepSize}
	 * @param amplitude				{@link maestro.v2.gen.gd.GD#amplitude}
	 * @param uniformProb			{@link maestro.v2.gen.gd.GD#uniformProb}
	 */
	public void addGDGenerator(double greed, double solVicinities, double powerVicinityWeight, 
						double stepSize, double amplitude, double uniformProb)
	{
		Generator gd		= new GD(greed, solVicinities, powerVicinityWeight, stepSize, 
										amplitude, uniformProb);
		GenWrapper wrapper	= new GenWrapper(gd);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a generator wrapper object to the generator lists and checks names are unique
	 * @param wrapper The generator wrapper to add
	 */
	private void addGenWrapper(GenWrapper wrapper)
	{
		generators.add(wrapper);
		genOrigOrder.add(wrapper);
		checkNames();
	}
	
	/**
	 * Adds suffixes to the identifiers of the generators of the same kind to distinguish them
	 */
	private void checkNames()
	{
		Hashtable<String, Point2I> counts = new Hashtable<String, Point2I>();
		for(GenWrapper generator : genOrigOrder)
		{
			generator.setSuffix("");
			String id = generator.getId();
			if(counts.containsKey(id))
			{
				Point2I point = counts.get(id);
				point.setX(point.getX() + 1);
			}
			else
				counts.put(id, new Point2I(1, 0));
		}
		for(GenWrapper generator : genOrigOrder)
		{
			String id = generator.getId();
			Point2I point = counts.get(id);
			if(point.getX() > 1)
			{
				point.setY(point.getY() + 1);
				generator.setSuffix(" " + point.getY());
			}
		}
	}
	
	/**
	 * Clears the generator methods
	 */
	public void clearGenerators()
	{
		generators.clear();
		genOrigOrder.clear();
	}
	
	/**
	 * Returns the identifier of the generator method
	 * @param index The index of the generator method
	 * @return The identifier of the generator method
	 */
	public String getGeneratorId(int index)
	{
		if(index == -1)
			return "Random";
		else
			return genOrigOrder.get(index).getId();
	}
	
	/**
	 * Returns the short identifier of the generator method
	 * @param index The index of the generator method
	 * @return The short identifier of the generator method
	 */
	public String getGeneratorShortId(int index)
	{
		if(index == -1)
			return "Rnd";
		else
			return genOrigOrder.get(index).getShortId();
	}
	
	/**
	 * Sets the optimization variables
	 * @param discVars The list of the discrete variables of the problem
	 * @param contVars The list of the continuous variables of the problem
	 */
	public void setVariables(ArrayList<DiscVar> discVars, ArrayList<ContVar> contVars)
	{
		if(generators.size() == 0)
			defaultGenerators();
		for(GenWrapper generator : generators)
		{
			generator.clearVariables();
			if(discVars != null)
				for(DiscVar var : discVars)
					generator.addDiscVariable(var);
			if(contVars != null)
				for(ContVar var : contVars)
					generator.addContVariable(var);
		}
	}
	
	/**
	 * Initializes the generator manager for a new inner cycle run. The generators methods must
	 * have been defined before calling this method.
	 * @param population The list of partitions that make up the current population of solutions. 
	 * Each partition has a different rarity standard and are sorted in ascending rarity standard 
	 * order.
	 * @param popSize The number of solutions in the current population
	 */
	public void initInnerCycle(Population population, int popSize)
	{
		Collections.shuffle(generators);
		this.population = population;
		this.popSize = popSize;
		lastGen = -1;
		firstLap = true;
	}
	
	/**
	 * Generates values for new solutions using the next generator method in line. If this
	 * generator produces no solutions, the next one is used until at least one solution root is
	 * generated.
	 * @param icIndex The index of the current inner cycle run, starting from 1
	 * @param eliteHistory A list with the hall-of-fame solutions (best-so-far) in the order they
	 * were evaluated
	 * @return The generated values for new solutions
	 */
	public synchronized ArrayList<SolutionRoot> generateSolutions(int icIndex,
			ArrayList<SolutionWrapper> eliteHistory)
	{		
		ArrayList<SolutionRoot> roots = new ArrayList<>();
		while (roots.size() == 0)
			roots.addAll(attemptGeneration(icIndex, eliteHistory));
		return roots;
	}
	
	/**
	 * Generates values for new solutions using the next generator method in line
	 * @param icIndex The index of the current inner cycle run, starting from 1
	 * @param eliteHistory A list with the hall-of-fame solutions (best-so-far) in the order they
	 * were evaluated
	 * @return The generated values for new solutions
	 * @throws RuntimeException If the population is null or if the population is too small
	 */
	private ArrayList<SolutionRoot> attemptGeneration(int icIndex, 
														ArrayList<SolutionWrapper> eliteHistory)
	{		
		if(population == null)
			throw new RuntimeException("Population is null");
		
		// Organize root population
		ArrayList<Solution> rootPop = population.getAllSolutionsBestToWorst();
		
		// Verify population size
		if(rootPop.size() < MIN_POP_SIZE)		
			throw new RuntimeException("Population is too small; size = " + rootPop.size());

		// Select generator
		GenWrapper gen			= null;
		int genCount 			= 0;
		boolean okGen			= false;
		int zeroGen				= 0;
		while(!okGen)
		{
			// Update last generator index
			if(lastGen == generators.size() - 1)
			{
				lastGen 		= 0;
				firstLap 		= false;
			}
			else
				lastGen 		= lastGen + 1;
			
			gen 				= generators.get(lastGen);
			genCount 			= 0;
			synchronized(population)
			{
				// Compute the number of solutions to generate
				if(firstLap || zeroGen >= generators.size())
					genCount 	= Math.max(1, (int)(genRatio*popSize));
				else
					genCount 	= computeGenCount(lastGen, eliteHistory);
				genCount 		= Math.max(genCount, Math.max(absGenMin, (int)(genMin*popSize)));
			
				if(genCount > 0)
					okGen		= true;
				else
					zeroGen++;
			}
		}
		
		// Generate new solutions
		long startTime 					= System.currentTimeMillis();
		ArrayList<SolutionRoot> roots	= gen.generateSolutions(rootPop, genCount);
		long delta						= System.currentTimeMillis() - startTime;
		int count						= roots.size();
		double perSolution				= count == 0 ? 0.0 : ((double)delta)/count;
		int genIndex = genOrigOrder.indexOf(generators.get(lastGen));
		for(SolutionRoot root : roots)
			root.setGenIndex(genIndex);
		genHist.add(icIndex + "\t" + gen.getShortId() + "\t" + count + "\t" + delta
					+ "\t" + perSolution);
		
		return roots;
	}
	
	/**
	 * Computes the number of solutions to generate by taking into account the relative weight of
	 * the generator as compared with that of the other generators
	 * @param genIndex The index of the generator
	 * @param eliteHistory A list with the hall-of-fame solutions (best-so-far) in the order they
	 * were evaluated
	 * @return The number of solutions to generate
	 */
	private int computeGenCount(int genIndex, ArrayList<SolutionWrapper> eliteHistory)
	{
		double genWeight = 0;
		
		// Compute population weights
		for(int i = 0 ; i < population.getPartitions().size() ; i++)
		{
			Partition part = population.getPartition(i);
			double percent = part.getGeneratorPercent(genIndex);
			genWeight += weightPop*percent;
			if(i == 0)
				genWeight += weightPart1*percent;
		}
		
		// Compute elite weights
		int genCount = 0;
		int rndCount = 0;
		int size = eliteHistory.size();
		for(SolutionWrapper sol : eliteHistory)
		{
			int index = sol.getGenIndex();
			if(index == genIndex)
				genCount++;
			else if(index == -1)
				rndCount++;
		}
		double partial = weightElite*(double)genCount/(double)(size - rndCount);
		genWeight += Double.isNaN(partial) ? 0 : weightElite*(double)genCount/
																(double)(size - rndCount);
		double weightSum = weightPop + weightPart1 + weightElite;
		
		// Compute number of solutions to generate
		double base = ((double)generators.size()*genWeight/weightSum);
		return Double.isNaN(base) ? 0 : (int)((double)popSize*genRatio*base);
	}
	
}

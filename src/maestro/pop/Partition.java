/**
 * Copyright 2017 Felipe Hernández
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the 
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

package maestro.pop;

import java.util.Hashtable;
import java.util.Queue;
import java.util.TreeSet;
import java.util.concurrent.LinkedBlockingQueue;

import maestro.solution.SolutionWrapper;

/**
 * This class allocates solutions belonging to a population. The partition has a maximum size 
 * (number of solutions) and a rarity standard (which all the solutions within should hold).
 * Optionally, the history of accepted solutions within the partition is kept.
 * @author Felipe Hernández
 */
public class Partition
{

	// --------------------------------------------------------------------------------------------
	// Attributes
	// --------------------------------------------------------------------------------------------
	
	/**
	 * The number of solutions the partition must allocate
	 */
	private int size;
	
	/**
	 * The rarity standard that the solutions allocated in the partition should hold. Solutions 
	 * with smaller rarity values are allocated only when no solutions that acknowledge the 
	 * standard are available.
	 */
	private double rarityStd;
	
	/**
	 * The set of solutions allocated in the partition
	 */
	private TreeSet<SolutionWrapper> solutions;
	
	/**
	 * A queue that keeps the history of acceptance of new solutions as boolean values: true for
	 * accepted and false for rejected. The history is only kept for a user-defined number of 
	 * solution offerings.
	 */
	private Queue<Boolean> acceptHist;
	
	/**
	 * The number of accepted new solutions within the range of analysis, specified by the user in
	 * the constructor
	 */
	private int acceptCount;
	
	/**
	 * A hash table with the number of solutions in the partition generated by each generator. The
	 * key is the identifier of the generator.
	 */
	private Hashtable<Integer, Integer> genCount;
	
	// --------------------------------------------------------------------------------------------
	// Constructors
	// --------------------------------------------------------------------------------------------

	/**
	 * Initializes a new empty population partition. By default, the partitions keeps no history on
	 * the accepted new solutions
	 * @param size The number of solutions the partition must allocate
	 * @param rarityStd The rarity standard that the solutions allocated in the partition should 
	 * hold
	 */
	public Partition(int size, double rarityStd)
	{
		this.size = size;
		this.rarityStd = rarityStd;
		solutions = new TreeSet<SolutionWrapper>();
		acceptHist = null;
		acceptCount = 0;
		genCount = new Hashtable<Integer, Integer>();
	}
	
	/**
	 * Initializes a new empty population partition. 
	 * @param size The number of solutions the partition must allocate
	 * @param rarityStd The rarity standard that the solutions allocated in the partition should 
	 * hold
	 * @param acceptHistSize The number of solutions offered starting from the last one in order to
	 * compute the rate of acceptance of new solutions
	 */
	public Partition(int size, double rarityStd, int acceptHistSize)
	{
		this.size = size;
		this.rarityStd = rarityStd;
		solutions = new TreeSet<SolutionWrapper>();
		if(acceptHistSize == 0)
			acceptHist = null;
		else
		{
			acceptHist = new LinkedBlockingQueue<Boolean>(acceptHistSize);
			for(int i = 0 ; i < acceptHistSize ; i++)
				acceptHist.offer(false);
		}
		acceptCount = 0;
		genCount = new Hashtable<Integer, Integer>();
	}
	
	// --------------------------------------------------------------------------------------------
	// Methods
	// --------------------------------------------------------------------------------------------
	
	/**
	 * @return The number of solutions the partition must allocate
	 */
	public int getSize() 
	{
		return size;
	}

	/**
	 * @return The rarity standard that the solutions allocated in the partition should hold
	 */
	public double getRarityStd() 
	{
		return rarityStd;
	}

	/**
	 * @return The set of solutions allocated in the partition
	 */
	public TreeSet<SolutionWrapper> getSolutions() 
	{
		return solutions;
	}
	
	/**
	 * Resets the partition by clearing the solutions
	 */
	public void reset()
	{
		solutions = new TreeSet<SolutionWrapper>();
		if(acceptHist != null)
		{
			for(int i = 0 ; i < acceptHist.size() ; i++)
				acceptHist.offer(false);
		}
		acceptCount = 0;
		genCount = new Hashtable<Integer, Integer>();
	}
	
	/**
	 * Adds a solution to the partition. The new solution is ordered according to the fitness and 
	 * rarity criteria. The least adequate solution is returned if the partition had the adequate 
	 * size already. <code>null</code> is returned if the partition has not exceeded its maximum
	 * size or if the added solution was already contained within (that is, it was identical to
	 * another as defined by the <code>compareTo()</code> method specified by the user) in the
	 * <code>Solution</code> interface implementation.
	 * @param solution The solution to be added
	 * @return The least adequate solution if the partition exceeds the maximum size. 
	 * <code>null</code> if the partition does not exceed the maximum size or if an identical 
	 * solution already existed in the partition. 
	 */
	public SolutionWrapper addSolution(SolutionWrapper solution)
	{
		// Offer new solution
		solution.setPartition(this);
		boolean different = false;
		SolutionWrapper dropped = null;
		synchronized(solutions)
		{
			different = solutions.add(solution);
			dropped =  solutions.size() > size ? solutions.pollFirst() : null;
		}
		boolean accepted = false;
		if(different)
			if(dropped == null)
				accepted = true;
			else
				accepted = solution.compareTo(dropped) == 0 ? false : true;
		
		// Update generation count
		if(accepted)
		{
			int genIndex = solution.getGenIndex();
			Integer count = genCount.get(genIndex);
			genCount.put(genIndex, count == null ? 1 : count + 1);
		}
		if(accepted && dropped != null)
		{
			int genIndex = dropped.getGenIndex();
			Integer count = genCount.get(genIndex);
			genCount.put(genIndex, count - 1);
		}
		
		// Update acceptance history
		if(acceptHist != null)
		{
			boolean head = acceptHist.poll();
			acceptHist.offer(accepted);
			acceptCount -= head ? 1 : 0;
			acceptCount += accepted ? 1 : 0;
		}
		return dropped;
	}
	
	/**
	 * @return The mean rarity of the solutions allocated in the partition
	 */
	public double getMeanRarity()
	{
		double raritySum = 0;
		synchronized(solutions)
		{
			for(SolutionWrapper solution : solutions)
				raritySum += solution.getRarity();
			return raritySum/solutions.size();
		}
	}
	
	/**
	 * @return The rate of acceptance of new solutions into the partition, computed using the 
	 * <i>n</i> last offered solutions. <i>N</i> is used as defined by the user. Returns 
	 * <code>Double.NaN</code> if no history of accepted solutions is being kept as specified by 
	 * the user in the constructor.
	 */
	public double getAcceptRate()
	{
		if(acceptHist == null)
			return Double.NaN;
		return (double)acceptCount/(double)acceptHist.size();
	}
	
	/**
	 * @param genIndex The index of the generator
	 * @return The percentage of generated (not by the initial random generation) solutions in the 
	 * partition that were generated using the specified generator
	 */
	public double getGeneratorPercent(int genIndex)
	{
		Integer count = genCount.get(genIndex);
		if(count == null || count == 0)
			return 0.0;
		return (double)count/(double)solutions.size();
	}
	
}
